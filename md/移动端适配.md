# 移动端适配

 最近在开发移动端的页面，所以粗略地又重头了解了一遍移动端的适配问题，本文将介绍一些常见的移动端适配方法，以及项目中遇到的一些适配问题，如有错误欢迎指正。

## 开篇

### 设备像素（Device Pixels）

设备屏幕的物理像素，表示屏幕上可以铺多少个点点，而不是一个绝对长度单位（例如in,mm）; 单位是px，比如iPhone6的 (750 x 1334px)

### 分辨率（Resolution）

一个物理概念
 对于屏幕，分辨率一般表示屏幕上显示的物理像素总和。比如，我们说iPhone6屏幕分辨率是(750 x 1334px)
 对于图像，概念等同于图像尺寸、图像大小、像素尺寸等等。比如，我们说(20 x 20px)的icon

### CSS像素（CSS Pixels）

是Web编程的概念，指的是CSS样式代码中使用的逻辑像素, 或者称为`设备独立像素`, 因为只与设备相关；
 1个CSS像素在不同设备上可能对应不同的物理像素数，这个比值是设备的属性（Device Pixel Ratio，设备像素比），比如，iPhone6：375 x 667px

通过 `document.documentElement.clientWidth/clientHeight / document.documentElement.getBoundingClientRect().width` 获取

在CSS规范中，长度单位可以分为绝对单位和相对单位。px是一个相对单位，相对的是设备像素（Device Pixels）

### 设备独立像素(device-independent pixels (DIP) / Density-independent Pixels (DP))

Android设备的特点是屏幕尺寸很多，因此为了显示能尽量和设备无关，提出了dip，参照的density是160。

```
// 当屏幕密度density为160（单位是ppi或者dpi，一个意思）时，px === dip
px = dip * density / 160 
// 所以
dip = px * 160 / density
复制代码
注: 此处只针对于Android, windows 也有 DIP 概念, 含义不同, IOS貌似不存在
```

### 设备像素比 (Device Pixel Ratio (DPR))

> Device pixel ratio, the ratio between physical pixels and logical pixels used by cascading style sheets (CSS): other names for it are “CSS Pixel Ratio” and “dppx” 表示1个CSS像素（宽度）等于几个物理像素（宽度）

```
DPR = 物理像素(设备像素) / 逻辑像素(css像素/设备独立像素) // [未缩放]
```

### 像素密度（PPI）

像素密度也叫显示密度或者屏幕密度，缩写为DPI(Dots Per Inch)或者PPI(Pixel Per Inch)

每英寸有多少个像素点（设备像素点），PPI越高，画质越好。

```
// 屏幕对角线的像素尺寸 / 物理尺寸（inch 英寸）
// w: 横向pixel
// h: 纵向pixel
// inch: 屏幕尺寸
PPI = Math.sqrt(w * w + h * h) / inch
Math.sqrt(750*750 + 1334*1334) / 4.7 = 326ppi
```




### 视口（viewport）

桌面上视口宽度等于浏览器宽度，但在手机上有所不同。

#### 布局视口(layout viewport)

手机上为了容纳为桌面浏览器设计的网站，默认布局视口宽度远大于屏幕宽度，为了让用户看到网站全貌，它会缩小网站 `document.documentElement.clientWidth`

#### 视觉视口(Visual viewport)

屏幕的可视区域，即物理像素尺寸, 可变, 与当前缩放值和设备的屏幕宽度有关 `visual viewport宽度 = ideal viewport宽度 / 当前缩放值` 可以通过`window.innerWidth`来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。

#### 理想视口(ideal viewport)

ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度 在移动开发时, 在meta[name='viewport']中, 通过`width = device-width`把当前的viewport宽度设置为理想视口, 否则宽度将默认为布局视口980

ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。早期所有iPhone理想视口为320x480px

所以，在没有缩放的情况下，屏幕的CSS像素宽度其实是指理想视口的宽度，而meta标签：

```
<meta name="viewport" content="width=device-width, inital-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
复制代码
```

指定了布局视口=理想视口，并且禁止缩放。所以添上width=device-width的viewport meta后页面变大了（一开始页面内容小得看不清），实际上是布局视口变小了

initial-scale=1 解决了 iphone、ipad 无论横竖屏都把宽度设为竖屏时 ideal viewport 的宽度 width=device-width 解决了IE 无论横竖屏都把宽度设为竖屏时 ideal viewport 的宽度

视觉视口与理想视口关系：

```
visual viewport宽度 = ideal viewport宽度 / 当前缩放值
当前缩放值 = ideal viewport宽度 / visual viewport宽度
复制代码
```

参考: [www.ayqy.net/blog/完全理解px…](http://www.ayqy.net/blog/完全理解px-dpr-dpi-dip/) [github.com/jawil/blog/…](https://github.com/jawil/blog/issues/21)



### 单位

Px(CSS pixels)

- 像素 (px) 是一种绝对单位（absolute units）， 因为无论其他相关的设置怎么变化，像素指定的值是不会变化的
- 其实是相对于某个设备而言的，不同设备指定的值大小还是有区别的

em

- 1em与当前元素的字体大小相同（更具体地说，一个大写字母M的宽度）。CSS样式被应用之前，浏览器给网页设置的默认基础字体大小是16像素，这意味着对一个元素来说1em的计算值默认为16像素。但是要小心—em单位是会继承父元素的字体大小，所以如果在父元素上设置了不同的字体大小，em的像素值就会变得复杂。现在不要过于担心这个问题，我们将在后面的文章和模块中更详细地介绍继承和字体大小设置。em是Web开发中最常用的相对单位。

ex, ch

- 分别是小写x的高度和数字0的宽度。这些并不像em那样被普遍使用或很好地被支持。

rem

- REM（root em）和em以同样的方式工作，但它总是等于默认基础字体大小的尺寸；继承的字体大小将不起作用，所以这听起来像一个比em更好的选择，虽然在旧版本的IE上不被支持 查看关于跨浏览器支持 [Debugging CSS](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Debugging_CSS).)

vw,vh

- 分别是视口宽度的1/100和视口高度的1/100，其次，它不像rem那样被广泛支持。 还有vmin,vmax...

百分比

### rem 和 vw 兼容对比

- rem

  ![rem](https://user-gold-cdn.xitu.io/2018/12/2/1676d0bf50ee84d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  

- vw

  ![vm](https://user-gold-cdn.xitu.io/2018/12/2/1676d0bf50f65692?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  



## 布局方案

### viewport 配置

```
<meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;">
```



### 1. 百分比+媒体查询( media )

```
@media (min-width:320px) { /* smartphones, portrait iPhone, portrait 480x320 phones (Android) */ }
@media (min-width:480px) { /* smartphones, Android phones, landscape iPhone */ }
@media (min-width:600px) { /* portrait tablets, portrait iPad, e-readers (Nook/Kindle), landscape 800x480 phones (Android) */ }
@media (min-width:801px) { /* tablet, landscape iPad, lo-res laptops ands desktops */ }
@media (min-width:1025px) { /* big landscape tablets, laptops, and desktops */ }
@media (min-width:1281px) { /* hi-res laptops and desktops */ }


min-width: 480px: Will target mobile devices in landsca

```



### 2. rem

rem: 根元素(html)的字体大小. 即  1rem = html中设置的font-size

获取设备宽度 `document.documentElement.getBoundingClientRect().width / document.documentElement.clientWidth`

原理: 实质时比例问题, 根据设计图比例计算出固定 rem 值 实现: 主要通过修改 html 的 fontSize

```
(function (doc, win) {
        var docEl = doc.documentElement,
            resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
            recalc = function () {
                var clientWidth = docEl.clientWidth;
                if (!clientWidth) return;
                if(clientWidth>=640){
                    docEl.style.fontSize = '100px';
                }else{
                    docEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; // 640: 可根据设计图来定
                }
            };

        if (!doc.addEventListener) return;
        win.addEventListener(resizeEvt, recalc, false);
        doc.addEventListener('DOMContentLoaded', recalc, false);
    })(document, window);

// or
使用flexible.js
https://github.com/amfe/lib-flexible/
```

缺点:

1. iframe 问题
2. 富文本问题
3. 高清方案
4. 部分android机型不兼容
5. 系统字体缩放时, 发生变化, 导致页面错乱，因为和根元素字体紧密联系；解决方案: 缩放还原
    1> [juejin.im/post/684490…](https://juejin.im/post/6844903507061932040)
    2> 基于 flexible.js 添加以下代码: [juejin.im/post/684490…](https://juejin.im/post/6844903679993053198)

可以使用`postcss-pxtorem `来对项目中的px进行转换，更多介绍请参考[官方文档](https://github.com/cuth/postcss-pxtorem)

```js
npm install postcss-pxtorem --save-dev

// 在postcss.config.js中设置，如何不需要转换也可以将px写出Px 
module.exports = {
  plugins: {
    autoprefixer: {
      browsers: ['Android >= 4.0', 'iOS >= 7']
    },
    'postcss-pxtorem': {
      rootValue: 75, // (Number | Function) 结果为：设计稿元素尺寸/16，比如元素宽320px,最终页面会换算成 20rem
      propList: ['*'], // (Array) 'font', 'font-size', 'line-height', 'letter-spacing'
      unitPrecision: 5, // (Number) 单位转换后保留的精度
      selectorBlackList: [], // (Array) 要忽略的选择器，保留为px
      replace: true, // (Boolean)替换包含rems的规则，而不添加后备
      mediaQuery: false, // (Boolean)允许在媒体查询中转换px。
      minPixelValue: 0, // (Number)设置要替换的最小像素值。
      exclude: /node_modules/i // (String, Regexp, Function) 要忽略并保留为px的文件路径。
    }
  }
}
```



### 3. vw/vh (css3新增属性)

- Viewport Height (vh): This unit is based on the height of the viewport.
- Viewport Width (vw): This unit is based on the width of the viewport
- 1vw: 1% of the viewport's width，即可视窗口宽度1%
- 1vh: 1% of the viewport's height，即可视窗口高度1%
- vmin：1% of the viewport's smaller dimension，即从vw和vh中取最小Math.min(vw, vh)
- vmax: 1% of the viewport's larger dimension，即从vw和vh中取最大Math.max(vw, vh)

实现:

```
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no" />
设计图尺寸:设计图元素尺寸 = 100vw:Y // Y 表示css样式中设计图某元素的大小, 单位vw
复制代码
```

缺点:

- 没有最大/最小限制, 当屏幕过于小，字体或内容太小，看不清，过大同理
- 兼容性: ios8/andorid4.4 以上(ios6/7部分支持) 参考https://caniuse.com/#feat=viewport-units

实际项目中可以使用`postcss-px-to-viewport`进行单位转换， 更多介绍参考看[官方文档](https://github.com/evrone/postcss-px-to-viewport)

```js
npm install postcss-px-to-viewport --save-dev

// 在postcss.config.js中设置
module.exports = {
  plugins: {
    autoprefixer: {
      browsers: ['Android >= 4.0', 'iOS >= 7']
    },
    'postcss-px-to-viewport': {
      unitToConvert: 'px', // (String) 需要转换的单位，默认为"px"
      viewportWidth: 320, //  (Number) 设计稿的视口宽度
      unitPrecision: 5, // (Number) 单位转换后保留的精度
      propList: ['*'], // (Array) 能转化为vw的属性列表
      viewportUnit: 'vw', // (String) 希望使用的视口单位
      fontViewportUnit: 'vw', // (String) 字体使用的视口单位
      selectorBlackList: [], // (Array) 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位
      minPixelValue: 1, // (Number) 设置最小的转换数值，如果为1的话，只有大于1的值会被转换
      mediaQuery: false, // (Boolean) 媒体查询里的单位是否需要转换单位
      replace: true, // (Boolean) 是否直接更换属性值，而不添加备用属性
      exclude: [], //  (Array or Regexp) 忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件
      include: [], // (Array or Regexp) 如果设置了include，那将只有匹配到的文件才会被转换，例如只转换 'src/mobile' 下的文件 (include: /\/src\/mobile\//)
      landscape: false, // (Boolean) 是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape)
      landscapeUnit: 'vw', // (String) 横屏时使用的单位
      landscapeWidth: 568 // (Number) 横屏时使用的视口宽度s
    }
  }
}

You can use special comments for ignore conversion of single lines:

/* px-to-viewport-ignore-next */ — on a separate line, prevents conversion on the next line.
/* px-to-viewport-ignore */ — after the property on the right, prevents conversion on the same line.
```



### 4. vw + rem

优点:

1. 实现简单，不依赖插件及第三方库，几行css代码就可以实现
2. 开发方便, 方便换算
3. 不影响px使用，完美兼容第三方组件库
4. 不存在富文本和iframe等兼容问题

实现: 以下实现把屏幕平均分成10份，即屏幕宽10rem, 以rem与vw关系: rem:vw = 10:1 或者 1rem = 10vw为依据 `100vw === 10 rem === document.documentElement` 前提: ``

1. html 的 font-size 等于 1/10 的视口宽度 (即: 1rem = 1 / 10 * 100vw => 等同于lib-flexible 中 document.documentElement.style.fontSize = clientWidth / 10) [此处取1/10, 因为在淘宝方案也是取这个值, 为了更好计算可以去其他值]

```
// $vw_design: 设计图尺寸
// $vw_fontsize: 设计图尺寸 / 10  假设把设计图分为10份, 每份的大小(设计图的1rem), 并以此为基数
html {
  font-size: ($vw_fontsize / $vw_design) * 100vw; // 直接写 10vw

  // 同时，通过Media Queries 限制根元素最大最小值
  @media screen and (max-width: 320px) {
    font-size: 32px;
  }
  @media screen and (min-width: 540px) {
    font-size: 54px;
  }
}
复制代码
```

1. 计算使用scss函数: 设计图元素尺寸 / (设计图尺寸 / 10) * 1rem

```
// $basesize: 设计图元素尺寸
@function rem($basesize) {
  @return ($basesize / $vw_fontsize) * 1rem; 
}

//简化
@function rem($basesize) {
  @return ($basesize / $vw_design) * 10rem; 
}


// 
// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推
$vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值
@function rem($px) {
     @return ($px / $vm_fontsize ) * 1rem;
}
// 根元素大小使用 vw 单位
$vm_design: 750;
html {
    font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; 
    // 同时，通过Media Queries 限制根元素最大最小值
    @media screen and (max-width: 320px) {
        font-size: 64px;
    }
    @media screen and (min-width: 540px) {
        font-size: 108px;
    }
}
// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小
body {
    max-width: 540px;
    min-width: 320px;
}
```

计算原理:

```
假设设计图某元素所占视口大小为 X, 单位为: vw

设计图某元素尺寸 / 设计图尺寸 = (X)vw / 100vw 
=> (X)vw = (设计图元素尺寸 / 设计图尺寸) * 100vw 
// 转化为以rem单位的数值Y
由于 (Y)rem = (X)vw / 10 （平局分成10份，vw:rem = 10:1）
=> (Y)rem = (设计图元素尺寸 / 设计图尺寸) * 10vw 
```

观察最后推论，于是也可以按照以下理解：

```
$design_width: 750
$divideNum: 10 //屏幕平均分成份数
@function px2rem($design_dom) {
    @return #{$design_dom/$design_width * $divideNum}rem
}

html {
    font-size: (100 / $divideNum)vw;
    //同时，通过Media Queries 限制根元素最大最小值
    @media screen and (max-width: 320 ) {
        font-size: 32;
    }
    @media screen and (min-width: 640 ) {
        font-size: 64;
    }
}
复制代码
```

参考: [juejin.im/post/684490…](https://juejin.im/post/6844903729007689736)

### 5. rem + js

js 动态设置 html {font-size: (clientWidth / 屏幕平均分成份数)px}

```
$design_width: 750
@function px2rem($dom) {
    @return #{$dom/$design_width * 屏幕分成份数}rem
}
复制代码
```

防止使用rem后，未设置font-size的元素继承使用根元素的font-zsize，重置body的font-size 为默认值（一般16px）或使用媒体查询字体响应式（320, 480, 640移动端尺寸）

```
body {
    font-size: 16px;
}
```



## 响应式布局方案

| 缩放布局        | 用户体验 | 兼容性       | 依赖js | 支持超大屏幕 | 需要修正字体 |
| :-------------- | :------- | :----------- | :----- | :----------- | :----------- |
| rem+media-query | 可       | IOS4.1 AN2.1 | ×      | √            | √            |
| rem+js          | 良       | IOS4.1 AN2.1 | √      | √            | √            |
| rem+vw          | 优       | IOS6.1 AN4.4 | ×      | √            | √            |
| vw              | 优       | IOS6.1 AN4.4 | ×      | ×            | ×            |

总结：

1. rem兼容性：ios4.1/android2.1
2. vw兼容性：ios6.1/android4.4
3. 超大屏幕时，rem可通过media query控制font-size 最大/小值
4. rem方案都需要修正body字体



百分比计算

1. 子元素的height或width中使用百分比，是相对于子元素的直接父元素
2. 子元素的top/bottom|left/right中使用百分比，是相对于直接非static定位(默认定位)的父元素的高度|宽度
3. 子元素的padding/margin中使用百分比，是相对于子元素的直接父元素的宽度
4. 子元素的border-radius/translate/background-size中使用百分比，是相对于自身的宽|高





参考：

[移动端适配总结](https://juejin.im/post/6844904190938972173)

[关于移动端适配，你必须要知道的](https://juejin.im/post/6844903845617729549)

[大厂是怎么做移动端适配的](https://mp.weixin.qq.com/s/uQ8c2Z6GJr4eyH3kidZt3g)